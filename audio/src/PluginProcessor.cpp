/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "HostParam.h"

// UI header, should be hidden behind a factory
#include <PluginEditor.h>

//==============================================================================
PluginAudioProcessor::PluginAudioProcessor()
{
#if 0
    // write default_hrir_wav binary into temporary file
    tempHrirFile = new TemporaryFile(".wav");
    ScopedPointer<FileOutputStream> out = tempHrirFile->getFile().createOutputStream();
    out->write(BinaryData::default_hrirs_wav, BinaryData::default_hrirs_wavSize);

    // save path of randomly named tempFile
    tempHrirFilePath = tempHrirFile->getFile().getFullPathName();
#endif

    // add automation params for host
    // NOTE: make sure automation in host is not interpolated for more precision
    // e.g. in Cubase by setting reduction level to 0%
    addParameter(new HostParam<Param>(sourceX));
    addParameter(new HostParam<Param>(sourceY));
    addParameter(new HostParam<Param>(sourceVol));
    addParameter(new HostParam<ParamStepped<eOnOffState>>(sourceMute));

    addParameter(new HostParam<Param>(referenceX));
    addParameter(new HostParam<Param>(referenceY));
    addParameter(new HostParam<Param>(referenceOrientation));
}

PluginAudioProcessor::~PluginAudioProcessor()
{
    tempHrirFile = nullptr;
}

//==============================================================================
const String PluginAudioProcessor::getName() const
{
#ifdef JucePlugin_Name
    return JucePlugin_Name;
#else
    return "juceSSR plugin";
#endif
}

const String PluginAudioProcessor::getInputChannelName(int channelIndex) const
{
    return String(channelIndex + 1);
}

const String PluginAudioProcessor::getOutputChannelName(int channelIndex) const
{
    return String(channelIndex + 1);
}

bool PluginAudioProcessor::isInputChannelStereoPair(int index) const
{
    ignoreUnused(index);
    return true;
}

bool PluginAudioProcessor::isOutputChannelStereoPair(int index) const
{
    ignoreUnused(index);
    return true;
}

bool PluginAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool PluginAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

bool PluginAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double PluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

//==============================================================================

int PluginAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int PluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

void PluginAudioProcessor::setCurrentProgram(int index)
{
    ignoreUnused(index);
}

const String PluginAudioProcessor::getProgramName(int index)
{
    ignoreUnused(index);
    return String();
}

void PluginAudioProcessor::changeProgramName(int index, const String& newName)
{
    ignoreUnused(index, newName);
}

//==============================================================================

// SSR configuration args stuff
namespace {
    char* ssr_argv[] = { "ssr_juce", "--binaural", "--no-ip-server", "--no-gui", "--no-tracker", "--verbose" };
    int ssr_argc = sizeof(ssr_argv) / sizeof(ssr_argv[0]);
}

void PluginAudioProcessor::prepareToPlay(double sRate, int samplesPerBlock)
{
    // delete previous created tempHrirFile with incompatible sample rate if necessary
    if (sRate != hrirFileSampleRate && tempHrirFile != nullptr)
    {
        tempHrirFile->deleteTemporaryFile();
        tempHrirFile = nullptr;
    }

    // if no tempHrirFile is available then create new tempHrirFile
    if (tempHrirFile == nullptr)
    {
        // read default_hrirs_wav from memory and put into an AudioSampleBuffer
        MemoryInputStream *in = new MemoryInputStream(BinaryData::default_hrirs_wav, BinaryData::default_hrirs_wavSize, false);
        ScopedPointer<AudioFormatReader> reader = WavAudioFormat().createReaderFor(in, true);

        AudioSampleBuffer hrirSampleBuffer(reader->numChannels, reader->lengthInSamples);
        reader->read(&hrirSampleBuffer, 0, reader->lengthInSamples, 0, true, true);

        /// \todo write via libsndfile
        // create temporary file
        tempHrirFile = new TemporaryFile(".wav");
        ScopedPointer<FileOutputStream> out = tempHrirFile->getFile().createOutputStream();
        out->write(BinaryData::default_hrirs_wav, BinaryData::default_hrirs_wavSize);

        //AudioFormatWriter *writer = WavAudioFormat().createWriterFor(out, sRate, reader->numChannels, reader->bitsPerSample, NULL, 0);
        if (sRate == hrirFileSampleRate)
        {
#if 0
            // write not resampled hrir file
            writer->writeFromAudioSampleBuffer(hrirSampleBuffer, 0, hrirSampleBuffer.getNumSamples());
#else
            // test write via libsndfile
            const char* path = "C:/Users/Nutty/Desktop/sndFileHrir.wav";
            SF_INFO sfinfo;
            sfinfo.channels = 256; //!< same problem as juce
            sfinfo.samplerate = reader->sampleRate;
            sfinfo.format = SF_FORMAT_WAV | SF_FORMAT_PCM_16;
            //SNDFILE *hrirFile = sf_open(path, SFM_WRITE, &sfinfo);

            // Create interleaved audio data
            float *interleavedBuffer;
            int numFrames = sfinfo.channels * hrirSampleBuffer.getNumSamples();
            interleavedBuffer = (float*)malloc(numFrames * sizeof(float));
            long k = 0;
            for (long i = 0; i < hrirSampleBuffer.getNumSamples(); i++)
            {
                for (int j = 0; j < sfinfo.channels; j++)
                {
                    interleavedBuffer[k + j] = hrirSampleBuffer.getSample(j, i);
                }
                k += sfinfo.channels;
            }

            SndfileHandle sndFile = SndfileHandle(path, SFM_WRITE, sfinfo.format, sfinfo.channels, sfinfo.samplerate);
            sndFile.write(interleavedBuffer, numFrames);
#endif
        }
        else
        {
            // resample hrir buffer
            double resampleRatio = hrirFileSampleRate / sRate;
            AudioSampleBuffer resampledHrirBuffer = AudioSampleBuffer(hrirSampleBuffer.getNumChannels(), hrirSampleBuffer.getNumSamples() / resampleRatio);
            const float **readBuffer = hrirSampleBuffer.getArrayOfReadPointers();
            float **writeBuffer = resampledHrirBuffer.getArrayOfWritePointers();

            ScopedPointer<LagrangeInterpolator> resampler = new LagrangeInterpolator();
            for (int i = 0; i < hrirSampleBuffer.getNumChannels(); ++i)
            {
                resampler->process(resampleRatio, readBuffer[i], writeBuffer[i], resampledHrirBuffer.getNumSamples());
            }
#if 0
            // write resampled hrir file
            writer->writeFromAudioSampleBuffer(resampledHrirBuffer, 0, resampledHrirBuffer.getNumSamples());
#endif
        }
        //out.release();
        //delete writer;

        // save path of randomly named tempFile
        tempHrirFilePath = tempHrirFile->getFile().getFullPathName();
    }

    // configurate SSR
    auto conf = ssr::configuration(ssr_argc, ssr_argv);
    conf.renderer_params.set<int>("sample_rate", static_cast<int>(sRate));
    conf.renderer_params.set<int>("block_size", samplesPerBlock);
    conf.renderer_params.set<int>("in_channels", getNumInputChannels());
    conf.renderer_params.set<int>("out_channels", getNumOutputChannels());

    conf.renderer_params.set("hrir_size", 0); // "0" means use all that are there
    conf.renderer_params.set("hrir_file", tempHrirFilePath);

    try
    {
        // create renderer
        renderer.reset(new ssr::BinauralRenderer(conf.renderer_params));
        renderer->load_reproduction_setup();

        // add mono input source
        apf::parameter_map sourceParam;
        sourceID = renderer->add_source(sourceParam);

        setupSuccessful = true;
    }
    catch (...)
    {
        setupSuccessful = false;
    }
}

void PluginAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void PluginAudioProcessor::processBlock(AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    ignoreUnused(midiMessages);

    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear(i, 0, buffer.getNumSamples());

    /// \todo how to handle mono input from host correctly?
    // choose between left or right channel for stereo input
    int channelIndex = static_cast<int>(inputChannel.getStep());

    // get source input level
    float inputLevel;
    sourceMute.getStep() == eOnOffState::eOn ? inputLevel = 0.0f : inputLevel = buffer.getRMSLevel(channelIndex, 0, buffer.getNumSamples());
    sourceLevel.set(Param::toDb(inputLevel), true);

    if (setupSuccessful)
    {
        // set listener parameter
        Position listenerPos = Position(referenceX.get(), referenceY.get());
        renderer->state.reference_position.setRT(listenerPos);
        renderer->state.reference_orientation.setRT(Orientation(referenceOrientation.get() + refOrientationOffset));
        renderer->state.amplitude_reference_distance.setRT(amplitudeReferenceDistance.get());

        // set source parameter
        ssr::RendererBase<ssr::BinauralRenderer>::Source *source = renderer->get_source(sourceID);
        Position sourcePos = Position(sourceX.get(), sourceY.get());
        source->position.setRT(sourcePos);
        source->orientation.setRT((listenerPos - sourcePos).orientation()); // quserinterface.cpp
        Source::model_t type;
        sourceType.getStep() == eSourceType::ePlane ? type = Source::model_t::plane : type = Source::model_t::point;
        source->model.setRT(type);
        source->mute.setRT(sourceMute.getStep() == eOnOffState::eOn);
        source->gain.setRT(Param::fromDb(sourceVol.get()));

        // calculate angle from which the source is seen
        // and confine angle to interval ]-180, 180], see qsourceproperties.cpp
        float ang = source->orientation.get().azimuth - referenceOrientation.get() + refOrientationOffset;
        ang = std::fmod(ang, 360.0f);
        if (ang > 180.0f)
        {
            ang -= 360.0f;
        }
        else if (ang <= -180.0f)
        {
            ang += 360.0f;
        }
        sourceOrientation.setUI(ang);

        // call internal ssr process function of renderer
        renderer->audio_callback(getBlockSize()
            , buffer.getArrayOfWritePointers() + channelIndex // NOTE: write = read pointer (same address), read is just const
            , buffer.getArrayOfWritePointers());
    }

    // get ssr output level
    outputLevelLeft.set(Param::toDb(buffer.getRMSLevel(0, 0, buffer.getNumSamples())), true);
    outputLevelRight.set(Param::toDb(buffer.getRMSLevel(1, 0, buffer.getNumSamples())), true);

    /// \todo getCPUUsage() einbauen
}

//==============================================================================

bool PluginAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* PluginAudioProcessor::createEditor()
{
    return new PluginAudioProcessorEditor(*this);
}

//==============================================================================

void PluginAudioProcessor::getStateInformation(MemoryBlock& destData)
{
    SynthParams::writeXMLPatchHost(destData);
}

void PluginAudioProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    SynthParams::readXMLPatchHost(data, sizeInBytes);
}

//==============================================================================

// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PluginAudioProcessor();
}
