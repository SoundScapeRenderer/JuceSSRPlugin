/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginAudioProcessor.h"
#include "HostParam.h"

// UI header, should be hidden behind a factory
#include "PluginEditor.h"

//==============================================================================
PluginAudioProcessor::PluginAudioProcessor()
#if PERFORMANCE_TEST_JUCESSR == 1
    : pcProcessing("processing", 100, File(File::getSpecialLocation(
        File::SpecialLocationType::userDesktopDirectory).getFullPathName() + "/pcProcessing.txt"))
    , pcRendererSetup("rendererSetup", 100, File(File::getSpecialLocation(
        File::SpecialLocationType::userDesktopDirectory).getFullPathName() + "/pcRendererSetup.txt"))
    , pcRendering("rendering", 100, File(File::getSpecialLocation(
        File::SpecialLocationType::userDesktopDirectory).getFullPathName() + "/pcRendering.txt"))
#endif
{
    // add parameters that should be accessible for the host to a internal list
    // NOTE: make sure automation recordings in host are not interpolated for more
    // precision, especially for parameters with a wide value range
    // e.g. in Cubase by setting reduction level to 0%
    addParameter(new HostParam<Param>(sourceX));
    addParameter(new HostParam<Param>(sourceY));
    addParameter(new HostParamLog<Param>(sourceVol, sourceVol.getDefaultUI()));
    addParameter(new HostParam<ParamStepped<eOnOffState>>(sourceMute));

    addParameter(new HostParam<Param>(referenceX));
    addParameter(new HostParam<Param>(referenceY));
    addParameter(new HostParam<Param>(referenceOrientation));
}

PluginAudioProcessor::~PluginAudioProcessor()
{
    tempHrirFile = nullptr;
}

//==============================================================================
const String PluginAudioProcessor::getName() const
{
#ifdef JucePlugin_Name
    return JucePlugin_Name;
#else
    return "juceSSR plugin";
#endif
}

const String PluginAudioProcessor::getInputChannelName(int channelIndex) const
{
    return String(channelIndex + 1);
}

const String PluginAudioProcessor::getOutputChannelName(int channelIndex) const
{
    return String(channelIndex + 1);
}

bool PluginAudioProcessor::isInputChannelStereoPair(int index) const
{
    ignoreUnused(index);
    return true;
}

bool PluginAudioProcessor::isOutputChannelStereoPair(int index) const
{
    ignoreUnused(index);
    return true;
}

bool PluginAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
    return true;
#else
    return false;
#endif
}

bool PluginAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
    return true;
#else
    return false;
#endif
}

bool PluginAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double PluginAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

//==============================================================================

int PluginAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int PluginAudioProcessor::getCurrentProgram()
{
    return 0;
}

void PluginAudioProcessor::setCurrentProgram(int index)
{
    ignoreUnused(index);
}

const String PluginAudioProcessor::getProgramName(int index)
{
    ignoreUnused(index);
    return String();
}

void PluginAudioProcessor::changeProgramName(int index, const String& newName)
{
    ignoreUnused(index, newName);
}

//==============================================================================

void PluginAudioProcessor::prepareToPlay(double sRate, int samplesPerBlock)
{
    // configure SSR Renderer
    apf::parameter_map renderer_params;
    renderer_params.set<int>("sample_rate", static_cast<int>(sRate));
    renderer_params.set<int>("block_size", samplesPerBlock);
    
    // set hrir_file and hrir_size for binaural renderer, 0 for using complete size of hrir_file
    renderer_params.set("hrir_file", createTempHRIRFile(sRate));
    renderer_params.set("hrir_size", 0);

    try
    {
        // create renderer
        renderer.reset(new ssr::BinauralRenderer(renderer_params));
        renderer->load_reproduction_setup();

        // add only one input source
        apf::parameter_map sourceParam;
        sourceID = renderer->add_source(sourceParam);

        setupSuccessful = true;
    }
    catch (...)
    {
        setupSuccessful = false;
    }
}

void PluginAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void PluginAudioProcessor::processBlock(AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
#if PERFORMANCE_TEST_JUCESSR == 1
    pcProcessing.start();
#endif
    ignoreUnused(midiMessages);

    if (setupSuccessful)
    {
        // In case we have more outputs than inputs, this code clears any output
        // channels that didn't contain input data, (because these aren't
        // guaranteed to be empty - they may contain garbage).
        // I've added this to avoid people getting screaming feedback
        // when they first compile the plugin, but obviously you don't need to
        // this code if your algorithm already fills all the output channels.
        for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
            buffer.clear(i, 0, buffer.getNumSamples());

        // update host audio play head information to get transport state
        updateHostInfo();
        AudioPlayHead::CurrentPositionInfo hostPlayHead = positionInfo[getGUIIndex()];

        // update plugin source input level
        bool sourceIsMuted = sourceMute.getStep() == eOnOffState::eOn;
        float inputLevel;
        sourceIsMuted ? inputLevel = 0.0f : inputLevel = buffer.getRMSLevel(0, 0, buffer.getNumSamples());
        sourceLevel.set(Param::toDb(inputLevel));

        // update SSR data and call process function of SSR renderer only if host is playing
        if (hostPlayHead.isPlaying)
        {
#if PERFORMANCE_TEST_JUCESSR == 1
            pcRendererSetup.start();
#endif
            // update listener parameter
            Position listenerPos = Position(referenceX.get(), referenceY.get());
            renderer->state.reference_position.setRT(listenerPos);
            renderer->state.reference_orientation.setRT(Orientation(referenceOrientation.get() + refOrientationOffset));
            renderer->state.amplitude_reference_distance.setRT(amplitudeReferenceDistance.get());

            // update source parameter
            ssr::RendererBase<ssr::BinauralRenderer>::Source *source = renderer->get_source(sourceID);
            Position sourcePos = Position(sourceX.get(), sourceY.get());
            source->position.setRT(sourcePos);
            source->orientation.setRT((listenerPos - sourcePos).orientation());
            Source::model_t type;
            sourceType.getStep() == eSourceType::ePlane ? type = Source::model_t::plane : type = Source::model_t::point;
            source->model.setRT(type);
            source->mute.setRT(sourceIsMuted);
            source->gain.setRT(Param::fromDb(sourceVol.get()));
#if PERFORMANCE_TEST_JUCESSR == 1
            pcRendererSetup.stop();
            pcRendering.start();
#endif

            // call internal process function of SSR renderer
            renderer->audio_callback(getBlockSize()
                , buffer.getArrayOfWritePointers() // NOTE: write = read pointer, read is just const
                , buffer.getArrayOfWritePointers());
#if PERFORMANCE_TEST_JUCESSR == 1
            pcRendering.stop();
#endif

            // normalize volume due to missing normalization in the convolution of the SSR renderer
            if (getSampleRate() != 44100.0)
            {
                // reference is volume at sample rate of 44.1 kHz, for now
                float gain = (static_cast<float>(44100.0 / getSampleRate()));
                for (int c = 0; c < buffer.getNumChannels(); ++c)
                {
                    FloatVectorOperations::multiply(buffer.getWritePointer(c, 0), gain, buffer.getNumSamples());
                }
            }
        }

        // update plugin output level
        outputLevelLeft.set(Param::toDb(buffer.getRMSLevel(0, 0, buffer.getNumSamples())));
        outputLevelRight.set(Param::toDb(buffer.getRMSLevel(1, 0, buffer.getNumSamples())));
    }
    else
    {
        buffer.clear();
    }

#if PERFORMANCE_TEST_JUCESSR == 1
    pcProcessing.stop();
#endif
}

//==============================================================================

bool PluginAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* PluginAudioProcessor::createEditor()
{
    return new PluginAudioProcessorEditor(*this);
}

//==============================================================================

void PluginAudioProcessor::getStateInformation(MemoryBlock& destData)
{
    PluginParams::writeXMLPatchHost(destData);
}

void PluginAudioProcessor::setStateInformation(const void* data, int sizeInBytes)
{
    PluginParams::readXMLPatchHost(data, sizeInBytes);
}

//==============================================================================

String PluginAudioProcessor::createTempHRIRFile(double sRate)
{
    // load suitable HRIR file into a MemoryInputStream
    // NOTE: comparing doubles (sample rates) is not nice but here it is possible since (pre-resampled) HRIR files
    // from memory only has zeros after dots and there are no prior calculations involved
    MemoryInputStream *in;
    sRate == 48000.0 ? in = new MemoryInputStream(BinaryData::soxHrir48000_wav, BinaryData::soxHrir48000_wavSize, false)
        : (sRate == 96000.0 ? in = new MemoryInputStream(BinaryData::soxHrir96000_wav, BinaryData::soxHrir96000_wavSize, false)
            : in = new MemoryInputStream(BinaryData::hrirs_fabian_wav, BinaryData::hrirs_fabian_wavSize, false));

    // read wav MemoryInputStream into hrirFileBuffer
    ScopedPointer<AudioFormatReader> hrirFileReader = WavAudioFormat().createReaderFor(in, true);
    AudioSampleBuffer hrirFileBuffer(static_cast<int>(hrirFileReader->numChannels), static_cast<int>(hrirFileReader->lengthInSamples));
    hrirFileReader->read(&hrirFileBuffer, 0, static_cast<int>(hrirFileReader->lengthInSamples), 0, true, true);

    // resample default hrir buffer if necessary
    AudioSampleBuffer resampledHrirFileBuffer;
    if (sRate != hrirFileReader->sampleRate)
    {
        // preparations for resampling
        ScopedPointer<LagrangeInterpolator> resampler = new LagrangeInterpolator();
        double speedRatio = hrirFileReader->sampleRate / sRate;
        int resampledLengthInSamples = static_cast<int>(std::round(hrirFileReader->lengthInSamples / speedRatio));
        resampledHrirFileBuffer = AudioSampleBuffer(static_cast<int>(hrirFileReader->numChannels), resampledLengthInSamples);

        // resample data of hrirFileBuffer into resampledHrirFileBuffer
        const float **readBuffer = hrirFileBuffer.getArrayOfReadPointers();
        float **writeBuffer = resampledHrirFileBuffer.getArrayOfWritePointers();
        for (int i = 0; i < static_cast<int>(hrirFileReader->numChannels); ++i)
        {
            resampler->process(speedRatio, readBuffer[i], writeBuffer[i], resampledLengthInSamples);
        }
    }

    // create interleaved audio data buffer for writing a multi channel wav using libsndfile
    AudioSampleBuffer *bufferToUse = sRate == hrirFileReader->sampleRate ? &hrirFileBuffer : &resampledHrirFileBuffer;
    int numFrames = static_cast<int>(hrirFileReader->numChannels) * bufferToUse->getNumSamples();
    float *interleavedBuffer = (float*)malloc(numFrames * sizeof(float));

    long k = 0;
    for (long i = 0; i < bufferToUse->getNumSamples(); ++i)
    {
        for (int j = 0; j < static_cast<int>(hrirFileReader->numChannels); ++j)
        {
            interleavedBuffer[k + j] = bufferToUse->getSample(j, i);
        }
        k += static_cast<int>(hrirFileReader->numChannels);
    }

    // create temporary file in the system's default temporary file location
    tempHrirFile = new TemporaryFile(".wav");
    String tempHrirFilePath = tempHrirFile->getFile().getFullPathName();

    // write wav into TemporaryFile using libsndfile
    const char *path = tempHrirFilePath.getCharPointer();
    auto format = SF_FORMAT_WAV | SF_FORMAT_PCM_16;
    SndfileHandle sndFile = SndfileHandle(path, SFM_WRITE, format, static_cast<int>(hrirFileReader->numChannels), static_cast<int>(sRate));
    sndFile.write(interleavedBuffer, numFrames);

    return tempHrirFilePath;
}

void PluginAudioProcessor::updateHostInfo()
{
    // use double buffering
    if (AudioPlayHead* pHead = getPlayHead())
    {
        // save newest info in positionInfo[getAudioIndex()] and swap 
        // indexes if successful, otherwise reset it
        if (pHead->getCurrentPosition(positionInfo[getAudioIndex()]))
        {
            positionIndex.exchange(getGUIIndex());
            return;
        }
    }
    positionInfo[getAudioIndex()].resetToDefault();
}

//==============================================================================

// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new PluginAudioProcessor();
}
